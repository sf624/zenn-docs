---
title: "floatのビットパターンを表示する可搬なC++プログラムとは"
emoji: "💽"
type: "tech"
topics:
  - "cpp"
  - "c"
  - "低レイヤ"
  - "float"
  - "国際標準規格"
published: true
published_at: "2025-07-05 00:38"
---

## この記事を読むと…

- バイト (byte)、ビット（bit）、`unsigned char`との関係
- オブジェクト表現 (object representation)
- 値表現 (value representation)
- トリビアルコピー可能な型 (trivially copyable type)
- `std::memcpy`は何をやっているのか
- パディングビット
- strict aliasing rule
- エンディアン (endian) / バイトオーダー (byte order)
- 国際標準規格と慣習とのギャップ

これらの事柄について、理解できるようになります。

## はじめに

IEEE 754 binary32[^binary32]で実装された`float`のビット表現を出力するプログラムを作成したい。論理＆演算によってビットを出力するが、今回は話の都合上`unsigned int`が`float`と同じバイト数であり、これを使用すると仮定する。

[^binary32]: 詳しくは以前の記事参照： https://zenn.dev/misokatsu6/articles/e753e1a072c049

解答の一つとして、下記のようなものが考えられる。

```cpp
#include <iostream>
#include <cstring>
#include <cstdint>
#include <climits>
#include <limits>

static_assert(sizeof(float) * CHAR_BIT == 32);
static_assert(std::numeric_limits<float>::is_iec559);
static_assert(std::numeric_limits<float>::digits == 24);
static_assert(std::numeric_limits<float>::radix == 2);
static_assert(std::numeric_limits<float>::max_exponent == 128);

int main() {
  float x = 1.0f;
  std::uint32_t buf;
  std::memcpy(&buf, &x, sizeof(float));
  for (int i = 31; i >= 0; i--) {
    std::cout << ((buf & (1U << i)) ? '1' : '0');
    if (i == 31 || i == 23) {
        std::cout << ' ';
    }
  }
  std::cout << "\n";
}
```

`float`と同じ大きさの`uint32_t`に内容を`memcpy`でコピーして、あとはビット演算を施すことでビットパターンを表示するというものであり、[実行結果][result]は下記のようになるはずである。

```sh
0 01111111 00000000000000000000000
```

このようなプログラムによって、`float`(binary32)のビット表現を得ることができたが、これはたまたま上手くいっただけなのだろうか。なぜ`std::memcpy`をすれば、`float`のビットパターンがそのまま`uint32_t`に転写できたのだろうか。`float`や`uint32_t`ではなくて、他の型でも同じことができるのだろうか。

この手のメモリ周りを直接操作する話は色々と落とし穴がある。このあたりの理解があやふやになりがちだが大事なC/C++プログラミングの基礎的な部分を、国際標準規格に書かれた内容から丁寧に確認していく。このような一見シンプルなプログラムであっても正確に理解するには多少の分量が必要となる。

参照先として、今回はC++14の国際標準規格の最終ドラフト[n4140](https://timsong-cpp.github.io/cppwp/n4140)を使用する。またC++はCに基づくことから、C++14の"normative reference"であるC99の最終ドラフト[n1256](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)を使用する。

C++の言語規格において固有の意味合いを持つ用語については、初出時にはイタリック体と日本語訳で「*object*（オブジェクト）」のように表現し、日常用語ではないことを分かるように記載する。二回目以降は、日本語訳をそのまま書くため注意されたい。また、今回の解説に必要な内容に絞って引用し、細かい例外などについては記述が煩雑となるため省略する。脚注についても、あわせて読んでもらうと理解が深まると考える。

## メモリとは何か

まず、変数を格納しているメモリとはC/C++ではどのように位置づけられているのか、ここから確認する必要がある。

[[intro.memory]](https://timsong-cpp.github.io/cppwp/n4140/intro.memory) にはこのような記載がある。

- ストレージの基本単位は*byte*（バイト）と呼ぶ。
- バイトは、少なくともUTF-8の8ビットコードユニットを格納できる大きさでなければならない。
- バイトは、連続したビットによって構成され、そのビット数は処理系定義[^1]である。
- バイトは、それぞれ固有のアドレスを持つ。

メモリはそれぞれがアドレスで特定できるバイトから構成されて、1バイトはいくつかのビットによって構成されているようである。そして1バイトは8ビットコードユニットを格納できるので、少なくとも8bitであることが分かる。

[^1]: 従って、バイトは8bitではなく、例えば9bitであってもよい。

## オブジェクトとは何か

次に、C/C++における変数がそのバイトというものにどのように格納されるのかを確認する。

[[intro.object]](https://timsong-cpp.github.io/cppwp/n4140/intro.object#1) にはこのような記載がある。

- *object*（オブジェクト）[^object]とはストレージの領域のことである。
- オブジェクトは*definition*（定義）によって構築される。
- オブジェクトは*name*（名前）を持つことができる[^name]。
- オブジェクトは*type*（型）を持つ。
  - *object type*（オブジェクトの型）とは、そのオブジェクトが構築された型を意味する。
- オブジェクトのアドレスとは、オブジェクトが占有する最初のバイトのアドレスのことである。

オブジェクトとはいわゆる変数、名前というのはいわゆる変数名のことである。前節と合わせると、オブジェクトは基本単位をバイトとしてストレージの一部を占有しているということになる。

[^name]: 関数の戻り値などのように名前を持たないオブジェクトも存在する
[^object]: オブジェクト指向プログラミングでいうところのオブジェクトではない

## オブジェクト表現、値表現、パディングビットとは何か

さらに読み進めると[[basic.types]](https://timsong-cpp.github.io/cppwp/n4140/basic.types) にはこのような記載がある。

- **トリビアルコピー可能な型**を持つオブジェクトは、それを構成するバイト列を`char`または`unsigned char`[^3]の配列にコピーすることができる。`char`または`unsigned char`の配列から、コピーされた内容をオブジェクトにコピーし戻した場合、オブジェクトは元の値を復元することができる。
  - コピーの方法の例として、`std::memcpy`や`std::memmove`が使用できる[^4]。
- オブジェクトの*object representation*（**オブジェクト表現**）とは、オブジェクトが占有しているN個の連続した`unsigned char`型のオブジェクトのシーケンスのことである。Nは、オブジェクトの型を`T`とすると`sizeof(T)`である。
  - `sizeof`とはオブジェクト表現が占有するバイト数を返す演算子であり、`sizeof(unsigned char)`は1である[^sizeof]。
- オブジェクトの*value representation*（**値表現**）とは、オブジェクトの型の値を保持するビットの集合のことである。
- トリビアルコピー可能な型においては、値表現はオブジェクト表現に含まれる。
- *value*（値）とは、実装定義である値集合の中の1つの離散的な要素である。

[^3]: 従って、`signed char`が同等にコピーできるかどうかは不明である。
[^4]: この記述は、原文の[脚注](https://timsong-cpp.github.io/cppwp/n4140/basic.types#footnote-42)に基づいている。
[^sizeof]: https://timsong-cpp.github.io/cppwp/n4140/expr.sizeof#1

つまり、オブジェクト（表現）が占有しているストレージというのは、1つあたり1バイトの`unsigned char`型のオブジェクトの配列として見なすことができるようである。オブジェクト（表現）がNバイトなのであれば、それは`unsigned char [N]`と見なすことができる[^std::byte]。

[^std::byte]: C++17からは、`std::byte`が`unsigned char`の強い型付けとして定義された。`unsigned char`とバイトは本質的に同じなのである。

そして**トリビアルコピー可能な型**であれば、オブジェクトのバイト列は`std::memcpy`などによって`unsigned char`型の配列に、元の値を復元できる形で可逆的にコピーが可能である。なぜなら、トリビアルコピー可能な型`T`の値を決定するビット集合（＝値表現）は、オブジェクトが占有するバイト列（＝オブジェクト表現）に含まれるからである。`float`や`uint32_t`がトリビアルコピー可能な型であるかどうかは重要な情報であり、後のセクションで確認する。

さて、**オブジェクト表現**と**値表現**という二種類の用語が登場したのでその違いを明確にしよう。例えば、1バイトが8bitのシステムにおいて、`unsigned short`が（厭らしいことに）12bitの精度を持つ型であった仮定しよう。先ほどの説明から、あらゆるオブジェクトは整数バイトのストレージを占有するのであった（1.5バイトのみの占有は許容されない）。従って、この`unsigned short`を格納するために必要なストレージは少なくとも2バイトであり、実際に2バイトを占有するものとする。その場合、`sizeof(unsigned short)`は2となる。

この場合、オブジェクト表現とは`unsigned short`がストレージ上を占有している2バイトのことであり、値表現とは`unsigned short`がその整数値を決定するために必要な12bitのことである。このようにオブジェクト表現と値表現とでは扱っているビット数に差が生じることがあり、この差をパディングビットと言う。

```cpp
unsigned short x = 0xFFF;
┌─────────┐┌─────────┐
│ byte[1] ││ byte[0] │　<--- オブジェクト表現は2byte=16bit
└─────────┘└─────────┘
 **** 1111  1111 1111   <--- 値表現は12bit (*を除く)
         8192           <--- xの値は値表現から決定される

分かりやすいように右側に最下位バイトを記載する。
****がパディングビットである。
```

トリビアルコピーというのは、本当に必要な情報（値表現に関わるビット）がどこにあるのかには全く関知せずに、オブジェクト表現である`unsigned char`のシーケンス単位で無心でコピーするということである。パディングビットがあろうがなかろうが関係はない。トリビアル(trivial)は「取るに足らない」「些細な」を意味し[^trivial]、この性質をよく表している。

[^trivial]: 余談だが、この単語をみると「トリビアの泉」を思い出すのは私だけだろうか。

実際に、そのトリビアルコピーをしてくれる`std::memcpy`は何をやっているのだろうか。その宣言はこの通りである。

```cpp
void *memcpy(void * restrict s1, const void * restrict s2, size_t n);
```

このように、受け取るときの型は`void*`であって元の型が何であったのかの情報は落ちている。`std::memcpy`からすれば、元々が何の型だったのか一切知ることなく、単にオブジェクト表現であるバイト列を全コピーするだけである。

`std::memcpy`の疑似実装は下記のようなものとなっており、受け取ったポインタを`unsigned char*`[^20]と見なし、`unsigned char`型の配列のコピーをひたすら行うというものとなっている。実際には、処理系ごとに最適化が施されることによって高速化が捗られている。

[^20]: `unsigned char*`に変換してよい理由は後述の「ポインタキャストではダメなのか」で説明している

```cpp
void* memcpy(void* dest, const void* src, size_t n) {
    unsigned char* d = static_cast<unsigned char*>(dest);
    const unsigned char* s = static_cast<const unsigned char*>(src);
    for (size_t i = 0; i < n; ++i) {
        d[i] = s[i];
    }
    return dest;
}
```

さて、これには注意が必要である。なぜなら、今回は単に`float`から`uint32_t`にバイトをコピーしたいのではなく、binary32の表示に必要なビットの位置を特定して論理＆で演算をする必要があるからだ。もし`float`にパディングビットがある場合、表示に不要なビットもコピーされることからコピー先の`uint32_t`においてどのビットがパディングビットであるかを特定する必要があり、計算が煩雑になる。また`uint32_t`にパディングビットがある場合、そもそも必要なビット位置で論理＆演算ができない可能性がでてくる。従って、両者ともにパディングビットがないことを確認する必要がある。

まず`float`については、`float`のバイトサイズ（`sizeof(float)`）とバイトあたりビット数（`CHAR_BIT`）の積から`float`に使用されているビット数を計算し、それが32と一致することを確認することで、binary32で実装されていることを前提としてパディングビットが存在しないことを保証できる。

```cpp
// binary32で実装されている場合、floatにはパディングビットがないことが保証される
static_assert(sizeof(float) * CHAR_BIT == 32);
```

つぎに`uint32_t`であるが、Cの言語規格「7.18.1.1 Exact-width integer types」において、`uint32_t`はパディングビットがない32bit符号無し整数型であることが規定されている[^uint32_t]。従って、`uint32_t`についてはこれ以上に確認すべき内容はない。

[^uint32_t]: ちなみにパディングビットがない`uint32_t`が存在するということは、1バイトが少なくとも32bitの約数であることが決まる。従って、1バイトが8bit、16bit、32bitのいずれかとなるが、そのいずれであろうとも今回のプログラムでは問題にはならない。

## `float`、`uin32_t`はトリビアルコピー可能なのか

それでは、`float`や`uint32`がトリビアルコピー可能な型であることを確認する。

[[basic.fundamentals]](https://timsong-cpp.github.io/cppwp/n4140/basic.fundamental) にはこのような記載がある。

- `signed char`、`short int`、`int`、`long int`、`long long int`は*standard signed integer*（標準符号付き整数）型である。これ以外に、処理系定義の*extended signed integer*（拡張符号付き整数）型があってもよい。これら両者を合わせて、*signed interger*（符号付き整数）型と呼ぶ。
- `unsigned char`、`unsigned short int`、`unsigned int`、`unsigned long int`、`unsigned long long int`は*standard unsigned integer*（標準符号無し整数）型である。これ以外に、処理系定義の*extended unsigned integer*（拡張符号無し整数）型があってもよい。これら両者を合わせて、*unsigned integer*（符号無し整数）型と呼ぶ。
- 符号無し整数型は、その値表現に関わるビット数をnとしたときに$2^n$を法とした算術法則に従う。
- `bool`、`char`、`char16_t`、`char32_t`、`wchar_t`、符号付き整数型、符号無し整数型を合わせて*integral*[^integral]（整数）型と呼ぶ。
- 整数型は、"pure binary numeration system"（純粋な2進法）として値を定義しなければならない。すなわち、2の補数表現 ("2's complement")、1の補数表現 ("1's complement")、符号付き絶対値表現 ("signed magnitude representation")のいずれかでなければならない。
- `float`、`double`、`long double`は、*floating point*（浮動小数点）型である。
- 浮動小数点型の値表現は、処理系定義[^fp-imp]である。
- 整数型と浮動小数点型は、*arithmetic*（算術）型である。

[^fp-imp]: 今回は`float`がbinary32で実装されているものとして話を進めているが、全然違う実装はあり得る。
[^integral]: integralはintegerの同義語である

`float`は浮動小数点型であり、従って算術型であるということのようだ。また、`uint32_t`については先ほど言及したように符号無し整数型であり、従って同様に算術型ということになる。

ここでもう一度、[[basic.types]](https://timsong-cpp.github.io/cppwp/n4140/basic.types) に戻ってみると、更にこのような記載がある。

- 算術型、列挙型、ポインター型、メンバへのポインタ型、`std::nullptr_t`、そしてこれらのcv修飾は、あわせて*scalar type*（スカラー型）と呼ぶ。
- CV非修飾のスカラー型、トリビアルコピー可能なクラス、これらの配列、これらの非volatile[^9]・const修飾型は、あわせて*trivially copyable types*（トリビアルコピー可能な型）と呼ぶ

[^9]: C++17からは非volatileの制約がなくなった。つまり、`const volatile float`などもトリビアルコピー可能な型である。

従って、`float`と`uint32_t`はいずれもスカラー型であり、よってトリビアルコピー可能な型であるということが確定する。だから、`float`と`uint32_t`を構成するバイト列は`unsigned char`型の配列との間で可逆的にコピーすることができる。

```cpp
// floatはトリビアルコピー可能な型である
float x = 1.0f;
// 従って、floatはunsigned charの配列にコピーすることができる。
unsigned char buf[sizeof(float)];
std::memcpy(&buf, &x, sizeof(float));
```

さらに、重要なことの一つとして整数型についてそれを構成するビット列との対応が規定されている。整数型が2進法に従っていることは重要である。なぜなら、この記述によって整数型のビットパターンとそれが表す数字との間に一対一の関係が定義されるからである[^unsigned]。今回の例では、`1U << i`のように1という数字を左論理シフトすることで所望の位置のビットを論理＆で抽出するためのビットマスクを生成しているが、これは1が'0000 0001'のように最下位ビットだけ1であるようなビットパターンになることを前提としているため、このルールが必要となってくる。

[^5]: 従って、`char`と`signed char`については数字に対応しないビットパターンが理論的には存在し得る。
[^6]: 本稿では、IEEE 754 binary32で規定された値表現を持つものとして話を進める。
[^unsigned]: ただし符号付き整数型については、上述のように負の整数の表現方法に関していくつかのオプションがあるため、今回のようにビット操作をする場合には符号無し整数型を使うほうが混乱が避けられてよい。

## まとめ

以上をまとめると、もともとのコードが上手く動く理由は下記のようにコメントをした通りになる。

```cpp
#include <iostream>
#include <cstring>
#include <cstdint>
#include <climits>
#include <limits>

// binary32に従う場合にfloatのパディングビットがないことを確認する
static_assert(sizeof(float) * CHAR_BIT == 32);

// floatがIEEE 754規格に適合することことを確認する
static_assert(std::numeric_limits<float>::is_iec559);

// 以下の3つによってfloatがIEEE 754の中でも
// 特にbinary32として実装されていることを確認する
static_assert(std::numeric_limits<float>::digits == 24); 
static_assert(std::numeric_limits<float>::radix == 2);
static_assert(std::numeric_limits<float>::max_exponent == 128); 

int main() {
  float x = 1.0f;
  std::uint32_t buf;

  // &bufと&xによってそれぞれの最初のバイトアドレスを取得する
  // floatとstd::uint32_tはトリビアルコピー可能な型であるため
  // std::memcpyによってバイト表現をそのままお互いにコピー可能
  std::memcpy(&buf, &x, sizeof(float));

  for (int i = 31; i >= 0; i--) {
    // 転写されたbufの型であるstd::uint32_tは二進法を採用しているため、
    // ビット演算によって所望の位置のビットを抽出できる。
    std::cout << ((buf & (1U << i)) ? '1' : '0'); 
    if (i == 31 || i == 23) {
        std::cout << ' ';
    }
  }
  std::cout << "\n";
}
```

めでたしめでたし。

## 何かひっかからないだろうか…？

よくよく考えてみると、なぜ`float`から`uint32_t`にバイトコピーができたのだろうか。先ほどまでの説明で納得していればそれでもよいが、ここまで言及した国際標準規格の内容を厳密に解釈すれば、トリビアルコピー可能な型と`unsigned char`の配列との間で可逆的にオブジェクト表現のコピーができると言っているだけで、**任意の異なるトリビアルコピー可能な型**の間で可逆的にオブジェクト表現のコピーができるとまでは言っていないように見える。

```cpp
  float x = 1.0f;
  std::uint32_t buf;
  static_assert(sizeof(float) == sizeof(std::uint32_t));
  std::memcpy(&buf, &x, sizeof(float)); // 本当にOK?
```

どうやら、自分と同じような疑問を持っている人もいるようである。

https://stackoverflow.com/questions/51300626/is-stdmemcpy-between-different-trivially-copyable-types-undefined-behavior

これについて、自分が調べた限りでは国際標準規格はストレートに答えを述べていないように見える。先ほどの`std::memcpy`の仕様に踏み込むことで初めてこのような操作も認められると解釈するということだろうか。また、そもそもこれが認められなければ低レイヤーのプログラミングが不可能になるであろうから、これまでの慣習も含めて暗黙的に認められているということなのだろうと解釈することにする。

## その他の方法について

上記で紹介したもの以外に、たとえば`unsigned int`や`unsigned char []`へのコピー、もしくはコピーではなくポインタのキャストによって`float`のビットパターンを別の整数型として直接参照する方法などが考えられる。これらの手法を採用する際に、注意すべきことを以下に挙げる。

### `unsigned int`をコピー先とする場合

まず`unsigned int`を構成するビット数が32ビットであれば[^9]、`float`が余分なスペース無しでコピーできることが保証される。

[^9]: これは理論的な話ではなく、実際の話として`int`は32bitとは限らず、処理系によって16bitだったり64bitであることは十分ある話である。

```cpp
static_assert(sizeof(unsigned int) * CHAR_BIT == 32);
float x = 1.0f;
unsigned int buf;
std::memcpy(&buf, &float, sizeof(x));
```

しかしながら、これではパディングビットを含んでいる可能性を排除できておらず、後のビット演算時に精度不足によって期待しない結果をもたらす可能性がある。厳密には`unsigned int`が32ビットの数値をすべて表現できることを別途確かめる必要がある。

一例として、unsigned intの最大値が2^32-1=4294967295であることを`UINT_MAX`などで確かめれば大抵の場合はよいであろう。

```cpp
static_assert(UINT_MAX == 4294967295); // これで本当に良い？
```

**しかしながら**、これは処理系が`4294967295`を表現できる整数型を持っている場合に限られるため（たとえば`unsigned long long`でさえも16bitなシステムがあるかもしれない）、厳密さを期すのであれば`UINT_MAX`を1右シフト演算していって1が何ビット立っているのか計測するプログラムを組むのがよいであろう。詳細はCERTの[INT35-C](https://www.jpcert.or.jp/sc-rules/c-int35-c.html)を参照されたい。

### `unsigned char`の配列をコピー先とする場合

[[basic.fundamental]](https://timsong-cpp.github.io/cppwp/n4140/basic.fundamental)に記載があるが、`unsigned char`はナロー文字型であり、全てのビットが値表現に関わっていることが定められている。従って、追加で確認する内容はない。ただし、後述のエンディアンの問題については対応する必要がある。

### `std::memcpy`ではなくポインタキャストによる場合

この手の処理をするときに、`std::memcpy`によるコピーを介さずに、`float`のアドレスを`uint32_t`へのアドレスと見なして逆参照をすることで、直接的に変換する方法が思いつく。

```cpp
static_assert(sizeof(float) * CHAR_BIT == 32);
float x = 1.0f;
uint32_t y = *((uint32_t *)(&x)); // Undefined behavior!
```

**しかしながら**、これは未定義動作である。なぜなら、C++の規格によれば「プログラムがオブジェクトが持つ値を、以下の型を除くglvalue[^glvalue]を通してアクセスする場合の動作は未定義である」[^strict-aliasing]としているからである。

[^glvalue]: オブジェクトを参照する式(expression)のこと。ここでは、`*((uint32_t *)(&x))`が`x`というオブジェクトを参照する`uint32_t`型のglvalueであり、これが`x`の型である`float`と適合しない型であるため、strict type aliasingに違反するということである
[^strict-aliasing]: https://timsong-cpp.github.io/cppwp/n4140/basic.lval#10

「以下の型」とは、
- オブジェクトの動的型(dynamic type)[^dynamic_type]
...（略）...
- 動的型のベースクラス型[^base_class]
- `char`型または`unsigned char`型

[^dynamic_type]: 話がややこしいが、C++の規格による定義は[この通り](https://timsong-cpp.github.io/cppwp/n4140/defns.dynamic.type#type,dynamic)であり、glvalueが参照している*most derived object*の型のことである。*most dervived object*とは[ここ](https://timsong-cpp.github.io/cppwp/n4140/intro.object#4)に定義されているが、`class`/`struct`/`union`でない型は全て*most derived object*である。従って、`float`は動的型である。
[^base_class]: 本稿とは関係はないが、この例外によってクラスにおいてはポリモーフィズムが実現できる

である。今回の例では、`float`の動的型は`float`であり[^dynamic_type]、`float`のアドレスは他の型のアドレスと再解釈して逆参照することはダメということである。これは一般に"strict aliasing rule"と呼ばれるもので、CERTの[EXP39-C](https://www.jpcert.or.jp/sc-rules/c-exp39-c.html)にも記載がある。詳しくは、[^yoh][^gununu]などで詳しく解説されているが、平たくいえば「そんな変なことはしないことを仮定することでコンパイラを最適化したい」というのが理由である。

[^yoh]: https://yohhoy.hatenadiary.jp/entry/20120220/p1
[^gununu]: https://gununu.hatenadiary.jp/entry/20150201/1422769062

しかしながら、上述のように`unsigned char`は例外である。従って、`unsigned char *`と見なしてそれを配列アクセスするように手法を変更することにより問題を解消できる。（そもそもこれは、`std::memcpy`がやっていることと同じである。）

ただしこの場合も、エンディアンの問題があるため後述の対応が必要となる。

```cpp
static_assert(sizeof(float) * CHAR_BIT == 32);
float x = 1.0f;
unsigned char * buf = (unsigned char *)(&x);
for (int i = 0; i < sizeof(x); i++) {
  // buf[i]にアクセス
}
```

#### 補足

…と書いておいてあれだが、C++17ではこれは未定義動作になるような変更をしてしまったとかなんとかで、改善提案が行われているとのこと。少なくともC++29以降になりそうで、マジで言っているのかという感じ。

https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1839r7.html

https://github.com/cplusplus/papers/issues/592

### エンディアンについて

`unsigned char`の配列をコピー先に用いてビットパターンを表示する方法を取る場合、元の`float`の最上位バイトが配列の最初に来るのか、最後に来るのかを決定する必要がある。これはエンディアン、ないしはバイトオーダーと呼ばれる類の問題である[^endian]。x86-64ではリトルエンディアンであるが、他の処理系ではビッグエンディアンを採用しているものもある。

[^endian]: https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3

これに対応するためには、例えば2バイト以上の整数型で1を格納した変数を定義し、そのアドレスを`char *`ないしは`unsigned char *`に変換した際に、最初のバイトが1と解釈されるかどうかで決定できる。最初のバイトが1であればリトルエンディアン、最後のバイトが1であればビッグエンディアンである[^other_endian]。従って、下記のような関数を用意すればよい。なお、C++20以降であれば[std::endian](https://cpprefjp.github.io/reference/bit/endian.html)によって決定できる。

[^other_endian]: 論理的にはリトルエンディアンでもビッグエンディアンでもない環境が存在し得るが、現状ではほとんど見かけないため本稿では無視する。

```cpp
bool is_little_endian() {
    static_assert(sizeof(int) > 1);
    int x = 1;
    return *reinterpret_cast<char *>(&x) == 1;
}
```

あとは、エンディアンに従ってアクセスするべき配列位置を切り替えることで問題に対処できる。（[実行結果][result2])

```cpp
#include <iostream>
#include <cstring>
#include <cstdint>
#include <climits>
#include <limits>

static_assert(sizeof(float) * CHAR_BIT == 32);
static_assert(std::numeric_limits<float>::is_iec559);
static_assert(std::numeric_limits<float>::digits == 24);
static_assert(std::numeric_limits<float>::radix == 2);
static_assert(std::numeric_limits<float>::max_exponent == 128);

bool is_little_endian() {
    static_assert(sizeof(int) > 1);
    int x = 1;
    return *reinterpret_cast<char*>(&x) == 1;
}

int main() {
  float x = 1.0f;
  unsigned char * bytes = reinterpret_cast<unsigned char *>(&x);
  static_assert(sizeof(float) == 4);
  static_assert(CHAR_BIT == 8);

  bool little_endian = is_little_endian();
  for (int i = 31; i >= 0; i--) {
    unsigned char byte = little_endian ? bytes[i / 8] : bytes[3 - i / 8];
    std::cout << (byte & (1U << (i % 8)) ? '1' : '0');
    if (i == 31 || i == 23) {
        std::cout << ' ';
    }
  }
  std::cout << '\n';
}
```

エンディアン問題に正しく対処できているかどうかは、異なるエンディアンを持つシステムないしはそのエミュレータでプログラムをビルド・実行する必要がある。Linux (Ubuntu)であれば、下記のようにQEMUを使用することで、x86-64 (リトルエンディアン）とMIPS（ビッグエンディアン）の両方をエミュレートすることができる。

```sh
# x86-64での実行
x86_64-linux-gnu-g++ test.cpp && qemu-x86_64 ./a.out
# MIPSでの実行
mips-linux-gnu-g++ -static test.cpp && qemu-mips ./a.out
```

両方のエンディアンに対応したプログラムであれば、実行結果は同じとなる。

```sh
0 01111111 00000000000000000000000
0 01111111 00000000000000000000000
```

### C++20であれば…

[std::bit_cast](https://cpprefjp.github.io/reference/bit/bit_cast.html)を`std::memcpy`の代わりに使用可能である。バイトサイズが一致することをテンプレートパラメータ制約で保証してくれるため、使い勝手が少しいい。入出力の型がトリビアルコピー可能な型でなければいけないという事情は同じであるため、`std::memcpy`を簡略化したものだと捉えるとよい。

```cpp
  float x = 1.0f;

  // before C++20
  std::uint32_t buf;
  std::memcpy(&buf, &x, sizeof(float));

  // From C++20
  const std::uint32_t buf = bit_cast<std::uint32_t>(x);
```

[result]: https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:25,positionColumn:1,positionLineNumber:25,selectionStartColumn:1,selectionStartLineNumber:25,startColumn:1,startLineNumber:25),source:'%23include+%3Ciostream%3E%0A%23include+%3Ccstring%3E%0A%23include+%3Ccstdint%3E%0A%23include+%3Cclimits%3E%0A%23include+%3Climits%3E%0A%0Astatic_assert(sizeof(float)+*+CHAR_BIT+%3D%3D+32)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::is_iec559)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::digits+%3D%3D+24)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::radix+%3D%3D+2)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::max_exponent+%3D%3D+128)%3B%0A%0Aint+main()+%7B%0A++float+x+%3D+1.0f%3B%0A++std::uint32_t+buf%3B%0A++std::memcpy(%26buf,+%26x,+sizeof(float))%3B%0A++for+(int+i+%3D+31%3B+i+%3E%3D+0%3B+i--)+%7B%0A++++std::cout+%3C%3C+((buf+%26+(1U+%3C%3C+i))+%3F+!'1!'+:+!'0!')%3B%0A++++if+(i+%3D%3D+31+%7C%7C+i+%3D%3D+23)+%7B%0A++++++++std::cout+%3C%3C+!'+!'%3B%0A++++%7D%0A++%7D%0A++std::cout+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g151,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B14',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',tree:0,wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+gcc+15.1+(C%2B%2B,+Editor+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4

[result2]: https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:2,endLineNumber:34,positionColumn:1,positionLineNumber:1,selectionStartColumn:2,selectionStartLineNumber:34,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Ccstring%3E%0A%23include+%3Ccstdint%3E%0A%23include+%3Cclimits%3E%0A%23include+%3Climits%3E%0A%0Astatic_assert(sizeof(float)+*+CHAR_BIT+%3D%3D+32)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::is_iec559)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::digits+%3D%3D+24)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::radix+%3D%3D+2)%3B%0Astatic_assert(std::numeric_limits%3Cfloat%3E::max_exponent+%3D%3D+128)%3B%0A%0Abool+is_little_endian()+%7B%0A++++static_assert(sizeof(int)+%3E+1)%3B%0A++++int+x+%3D+1%3B%0A++++return+*reinterpret_cast%3Cchar*%3E(%26x)+%3D%3D+1%3B%0A%7D%0A%0Aint+main()+%7B%0A++float+x+%3D+1.0f%3B%0A++unsigned+char+*+bytes+%3D+reinterpret_cast%3Cunsigned+char+*%3E(%26x)%3B%0A++static_assert(sizeof(float)+%3D%3D+4)%3B%0A++static_assert(CHAR_BIT+%3D%3D+8)%3B%0A%0A++bool+little_endian+%3D+is_little_endian()%3B%0A++for+(int+i+%3D+31%3B+i+%3E%3D+0%3B+i--)+%7B%0A++++unsigned+char+byte+%3D+little_endian+%3F+bytes%5Bi+/+8%5D+:+bytes%5B3+-+i+/+8%5D%3B%0A++++std::cout+%3C%3C+(byte+%26+(1U+%3C%3C+(i+%25+8))+%3F+!'1!'+:+!'0!')%3B%0A++++if+(i+%3D%3D+31+%7C%7C+i+%3D%3D+23)+%7B%0A++++++++std::cout+%3C%3C+!'+!'%3B%0A++++%7D%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g151,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B14',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',tree:0,wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+gcc+15.1+(C%2B%2B,+Editor+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4